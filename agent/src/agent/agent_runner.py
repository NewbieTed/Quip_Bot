import logging
from pathlib import Path
from src.config import Config

# Import the graph cache from graph module
from src.agent.graph import get_cached_graph

# Get system prompt path from configuration
agent_config = Config.get_agent_config()
SYSTEM_PROMPT_PATH = Path(agent_config.get("system_prompt_path", "src/agent/prompts/system_prompt.txt"))

# Configure logger for this module
logger = logging.getLogger(__name__)


def load_system_prompt() -> str:
    return SYSTEM_PROMPT_PATH.read_text(encoding="utf-8").strip()


async def run_agent(member_message: str, server_id: int, channel_id: int, member_id: int):
    logger.info("Starting agent run for server_id=%s, channel_id=%s, member_id=%s, ", server_id, member_id, channel_id)
    
    if not isinstance(member_message, str) or not member_message.strip():
        logger.error("Invalid message provided: %s", type(member_message))
        yield "Error: Provided message must be a non-empty string."
        return

    # Get the cached graph (recompiles only if tools changed)
    logger.debug("Retrieving cached graph")
    graph = await get_cached_graph()
    
    # Log available tools for debugging
    from src.agent.tools import get_all_tools
    tools = get_all_tools()
    logger.info("Agent has access to %d local tools: %s", len(tools), [tool.name for tool in tools])

    config = {"configurable": {"thread_id": member_id}}
    system_message: str = load_system_prompt()
    messages = [
        {
            "role": "system",
            "content": system_message
        },
        {
            "role": "user",
            "content": member_message.strip()
        }
    ]

    # Create initial state with runtime context
    initial_state = {
        "messages": messages,
        "server_id": server_id,
        "channel_id": channel_id,
        "member_id": member_id
    }

    last_content = None
    previous_content = ""
    try:
        async for mode, chunk in graph.astream(initial_state, config,
                                               stream_mode=["updates", "messages", "custom"]):

            if mode == "messages":
                logger.debug("Received message stream chunk")
                if isinstance(chunk, dict) and "messages" in chunk:
                    partial_message = chunk["messages"][-1].content
                    # Only yield the new part of the message to avoid duplication
                    if partial_message and partial_message != previous_content:
                        if previous_content and partial_message.startswith(previous_content):
                            # Yield only the new part
                            new_part = partial_message[len(previous_content):]
                            if new_part:
                                yield new_part
                        else:
                            # Yield the full message if it's completely different
                            yield partial_message
                        previous_content = partial_message
                continue
                
            if mode == "custom":
                if isinstance(chunk, dict):
                    message = chunk.get('progress', chunk)
                else:
                    message = chunk
                logger.debug("Custom stream message: %s", message)
                yield message
                continue
                
            for value in chunk.values():
                if isinstance(value, dict) and "messages" in value:
                    last_content = value["messages"][-1].content
                    
    except Exception as e:
        logger.exception("Stream error occurred for member_id=%s: %s", member_id, str(e))
        yield f"Error: {str(e)}"

    if last_content and last_content != previous_content:
        logger.info("Agent run completed successfully for member_id=%s", member_id)
        yield last_content
    elif not last_content:
        logger.warning("No response generated by assistant for member_id=%s", member_id)
        yield "No response generated by the assistant."


